```sql
CREATE [TEMP] [UNLOGGED] TABLE [IF NOT EXISTS] scheme(default текущая).table_name [OF имя_типа]
	Имя_столбца Тип данных [COLLATE правило сортировки] [LIKE исходная_таблица [ вариант_копирования ]]
[
--			Ограничение_столбца:
			[ CONSTRAINT имя_ограничения ]
			{ NOT NULL |
			NULL |
			CHECK ( выражение ) [ NO INHERIT ] |
			DEFAULT выражение_по_умолчанию |
			UNIQUE параметры_индекса |
			PRIMARY KEY параметры_индекса |
			REFERENCES целевая_таблица [ ( целевой_столбец ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
			[ ON DELETE действие ] [ ON UPDATE действие ] }
			[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

	[
	ON COMMIT --Задает поведение временной таблицы в конце блока транзакции, есть 3 параметра:
		PRESERVE ROWS --Никакое  специальное действие не выполняется(по дефолту)
		DELETE ROWS --Все строки будут удаляться в конце каждого блока транзакции, при каждой фиксации транзакции выполняется TRUNCATE
		DROP --Дроп таблицы а конце текущего блока транзации
	]

--Ограничение_таблицы:
[CONSTRAINT имя_ограничения] --Имя ограничения таблицы выводится при ошибке,по дефолту генерится системой (пробелы в двойные кавычки)
UNIQUE имя_столбца/ов  [INCLUDING имя_столбца/ов] 
PRIMARY KEY имя_столбца/ов [INCLUDING имя_столбца/ов] 
EXCLUDE [ USING индексный_метод ] ( элемент_исключения WITH оператор [, ... ] ) параметры_индекса [ WHERE ( предикат ) ] |
FOREIGN KEY ( имя_столбца [, ... ] ) REFERENCES целевая_таблица [ ( целевой_столбец [, ... ] ) ]
[ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE действие ] [ ON UPDATE действие ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
]
[DISTRIBUTED имя_столбца/ов]


--TEMP|TEMPORARY  --Временная таблтца, которая удалится в конце сеанса или
--UNLOGGED --Создание не журналируемой таблицы (работает быстрее, не защищены от сбоя(они сразу усекаются, не реплицируются) индексы становятся не журналируемыми)
--IF NOT EXISTS  --не выдает ошибку, а замечании при создании табл с таким же именем ???
--OF имя_типа ???
/*???
INCLUDING - не будет требовать уникальность
Необязательное предложение INCLUDING позволяет добавить в индекс набор столбцов, для которых уникальность не будет требоваться. 
Заметьте, что хотя ограничение по столбцам не контролируется, оно всё же зависит от них. 
Как следствие, некоторые операции с этими столбцами (например, DROP COLUMN) могут повлечь каскадное удаление ограничения индекса. 
Более подробно об этом рассказывается в абзаце об INCLUDING в описании CREATE INDEX.
???*/
--UNIQUE - может содержать только уникальные значения(может быть несколько)(Null пропускается)
/*
PRIMARY KEY содержать только уникальные значения (только один)(NULL не допускаетя)
При добавлении ограничения уникальности и PRIMARY KEY  будет автоматически создан уникальный индекс-B-дерево для столбца или группы столбцов, перечисленных в ограничении. 
Образование первичного ключа из набора столбцов также добавляет метаданные о конструкции схемы, 
так как первичный ключ подразумевает, что другие таблицы могут ссылаться на этот набор столбцов, как на уникальный идентификатор строк.
*/
--COLLATE - назначает правило сортировки для столбца(по дефолту правило сортировки установленное для типа данных столбца) 




/*
INHERITS ( таблица_родитель [, ... ] )
Необязательное предложение INHERITS определяет список таблиц, от которых новая таблица будет автоматически наследовать все столбцы.
Родительские таблицы могут быть обычными или сторонними таблицами.
При использовании INHERITS создаётся постоянная связь дочерней таблицы с родительскими. 
Изменения схемы в родительских таблицах обычно также отражаются в дочерних, 
и по умолчанию при чтении родительских таблиц в результат включаются данные дочерней таблицы.

Когда в нескольких родительских таблицах оказываются столбцы с одним именем, происходит ошибка, 
за исключением случая, когда типы данных всех этих столбцов в таблицах совпадают. 
В этом случае одноимённые столбцы объединяются и формируют один столбец в новой таблице. 
Если имя столбца новой таблицы совпадает с именем одного из унаследованных столбцов, их типы так же должны совпадать, 
и в этом случае определения столбцов тоже сливаются в одну. Если в новой таблице явно указывается значение по умолчанию для нового столбца, 
это значение переопределяет любые значения по умолчанию, унаследованные этим столбцом. В противном случае, 
если значения по умолчанию определяются в разных родительских таблицах, эти определения должны совпадать, иначе произойдёт ошибка.
*/





EXCLUDE [ USING индексный_метод ] ( элемент_исключения WITH оператор [, ... ] ) параметры_индекса [ WHERE ( предикат ) ]
Предложение EXCLUDE определяет ограничение-исключение, которое гарантирует, что для любых двух строк, 
сравниваемых по указанным столбцам или выражениям с указанными операторами, результат не будет равен TRUE для всех сравнений. 
Если все указанные операторы проверяют равенство, это ограничение равносильно ограничению UNIQUE, хотя обычное ограничение уникальности будет работать быстрее. 
С другой стороны, в ограничениях-исключениях можно задавать более общие условия, чем простое условие на равенство. 
Например, можно задать ограничение, требующее, чтобы никакие две строки в таблице не содержали пересекающихся кругов (см. Раздел 8.8), применив оператор &&.

Ограничения-исключения реализуются с помощью индексов, так что каждый указанный в них оператор должен быть связан с соответствующим классом операторов 
(см. Раздел 11.9) для индексного_метода. Кроме того, операторы должны быть коммутативными. 
В каждом элементе_исключения можно дополнительно указать класс оператора и/или параметры сортировки, подробно описанные в CREATE INDEX.

Индексный метод доступа должен поддерживать amgettuple (см. Главу 58); в настоящее время это означает, что индексы GIN для этого не подходят. 
Хотя в ограничении-исключении можно использовать B-деревья и хеш-индексы, в этом мало смысла, так как такой подход ничем не лучше обычного ограничения уникальности. 
Так что на практике методом доступа всегда будет GiST или SP-GiST.

Параметр предикат позволяет указать ограничение-исключение для подмножества таблицы; внутри при этом создаётся частичный индекс. Заметьте, что предикат необходимо заключить в скобки.

REFERENCES внешняя_таблица [ ( внешний_столбец ) ] [ MATCH тип_совпадения ] [ ON DELETE действие ] [ ON UPDATE действие ] (ограничение столбца)
FOREIGN KEY ( имя_столбца [, ... ] ) REFERENCES внешняя_таблица [ ( внешний_столбец [, ... ] ) ] [ MATCH тип_совпадения ] [ ON DELETE действие ] [ ON UPDATE действие ] (ограничение таблицы)
Эти предложения определяют ограничение внешнего ключа, требующее, чтобы указанная группа из одного или нескольких столбцов новой таблицы содержала только такие значения, 
которым соответствуют значения в заданных внешних столбцах некоторой строки во внешней таблице. Если список внешних_столбцов опущен,
 в качестве него используется первичный ключ внешней_таблицы. В качестве внешних столбцов должны указываться столбцы неоткладываемого уникального ограничения или ограничение первичного ключа во внешней таблице. 
 Заметьте, что ограничения внешнего ключа, связывающие временные и постоянные таблицы, определить нельзя.

Значения, вставляемые в ссылающиеся столбцы, сверяются со значениями во внешних столбцах внешней таблицы с учётом заданного типа совпадения.
Возможны три типа совпадения: MATCH FULL (полное совпадение), MATCH PARTIAL (частичное совпадение) и тип по умолчанию, MATCH SIMPLE (простое совпадение). 
С MATCH FULL ни один из столбцов составного внешнего ключа не может содержать NULL, кроме случая, когда все внешние столбцы NULL; в этом случае строка может не иметь соответствия во внешней таблице. 
С MATCH SIMPLE любой из столбцов внешнего ключа может содержать NULL; при этом строка с NULL в одном из таких столбцов может не иметь соответствия во внешней таблице. Тип MATCH PARTIAL ещё не реализован. 
(Разумеется, чтобы вопросы со сравнением NULL не возникали, к столбцам, ссылающимся на внешние, можно применить ограничения NOT NULL.)

Кроме того, при изменении значений во внешних столбцах с данными в столбцах этой таблицы могут производиться определённые действия. Предложение ON DELETE задаёт действие, 
производимое при удалении некоторой строки во внешней таблице. Предложение ON UPDATE подобным образом задаёт действие, производимое при изменении значения в целевых столбцах внешней таблицы. 
Если строка изменена, но это изменение не затронуло целевые столбцы, никакое действие не производится. Ссылочные действия, кроме NO ACTION, нельзя сделать откладываемыми, даже если ограничение объявлено как откладываемое. 
Для каждого предложения возможные следующие варианты действий:

NO ACTION
Выдать ошибку, показывающую, что при удалении или изменении записи произойдёт нарушение ограничения внешнего ключа. Для отложенных ограничений ошибка произойдёт в момент проверки ограничения, 
если строки, ссылающиеся на эту запись, по-прежнему будут существовать. Этот вариант действия подразумевается по умолчанию.

RESTRICT
Выдать ошибку, показывающую, что при удалении или изменении записи произойдёт нарушение ограничения внешнего ключа. Этот вариант подобен NO ACTION, но эта проверка будет неоткладываемой.

CASCADE
Удалить все строки, ссылающиеся на удаляемую запись, либо поменять значения в ссылающихся столбцах на новые значения во внешних столбцах, в соответствии с операцией.

SET NULL
Установить ссылающиеся столбцы равными NULL.

SET DEFAULT
Установить в ссылающихся столбцах значения по умолчанию. (Если эти значения не равны NULL, во внешней таблице должна быть строка, соответствующая набору значений по умолчанию; в противном случае операция завершится ошибкой.)

Если внешние столбцы меняются часто, будет разумным добавить индекс для ссылающихся столбцов, чтобы действия по обеспечению ссылочной целостности, связанные с ограничением внешнего ключа, выполнялись более эффективно.

DEFERRABLE
NOT DEFERRABLE
Это предложение определяет, может ли ограничение быть отложенным. Неоткладываемое ограничение будет проверяться немедленно после каждой команды. 
Проверка откладываемых ограничений может быть отложена до завершения транзакции (обычно с помощью команды SET CONSTRAINTS). По умолчанию подразумевается вариант NOT DEFERRABLE. 
В настоящее время это предложение принимают только ограничения UNIQUE, PRIMARY KEY, EXCLUDE и REFERENCES (внешний ключ). Ограничения NOT NULL и CHECK не могут быть отложенными. 
Заметьте, что откладываемые ограничения не могут применяться в качестве решающих при конфликте в операторе INSERT с предложением ON CONFLICT DO UPDATE.

INITIALLY IMMEDIATE
INITIALLY DEFERRED
Для откладываемых ограничений это предложение определяет, когда ограничение должно проверяться по умолчанию. Ограничение с характеристикой INITIALLY IMMEDIATE (подразумеваемой по умолчанию) 
проверяется после каждого оператора. Ограничение INITIALLY DEFERRED, напротив, проверяется только в конце транзакции. Время проверки ограничения можно изменить явно с помощью команды SET CONSTRAINTS.

WITH ( параметр_хранения [= значение] [, ... ] )
Это предложение определяет необязательные параметры хранения для таблицы или индекса (за подробными сведениями о них обратитесь к Параметры хранения). 
Предложение WITH для таблицы может также включать указание OIDS=TRUE (или просто OIDS), устанавливающее, что каждая строка таблицы должна иметь собственный OID 
(Object IDentifier, идентификатор объекта), или указание OIDS=FALSE, устанавливающее, что строки не содержат OID. Если указание OIDS отсутствует, 
значение этого свойства по умолчанию зависит от конфигурационного параметра default_with_oids. (Если новая таблица унаследована от каких-либо таблиц, имеющих OID, 
свойство OIDS=TRUE задаётся принудительно, даже если в команде явно написано OIDS=FALSE.)

Если явно указано OIDS=FALSE или это подразумевается, в новой таблице не будут храниться значения OID и новый OID не будет генерироваться для каждой добавляемой в неё строки. 
Для обычных таблиц такое поведение предпочтительнее, так как оно сокращает потребление OID и тем самым откладывает зацикливание 32-битного счётчика OID. 
Как только происходит зацикливание, значения OID больше нельзя считать уникальными, что делает их значительно менее полезными. К тому же, исключение столбца OID из таблицы сокращает объём, 
необходимый для хранения таблицы на диске, на 4 байта для каждой строки (на большинстве платформ), что несколько улучшает производительность.

Для удаления данных OID из таблицы после её создания воспользуйтесь командой ALTER TABLE.

WITH OIDS
WITHOUT OIDS
Это устаревшее написание указаний WITH (OIDS) и WITH (OIDS=FALSE), соответственно. Если требуется определить одновременно свойство OIDS и параметры хранения, необходимо использовать синтаксис WITH ( ... ); см. ниже.










CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] имя_таблицы
    OF имя_типа [ (
  { имя_столбца WITH OPTIONS [ ограничение_столбца [ ... ] ]
    | ограничение_таблицы }
    [, ... ]
) ]
[ INHERITS ( таблица_родитель [, ... ] ) ]
[ WITH ( параметр_хранения [= значение] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE табл_пространство ]



[ CONSTRAINT имя_ограничения ]
{ CHECK ( выражение ) [ NO INHERIT ] |
  UNIQUE ( имя_столбца [, ... ] ) параметры_индекса [INCLUDING (имя_столбца [, ...])] |
  PRIMARY KEY ( имя_столбца [, ... ] ) параметры_индекса [INCLUDING (имя_столбца [, ...])] |
  EXCLUDE [ USING индексный_метод ] ( элемент_исключения WITH оператор [, ... ] ) параметры_индекса [ WHERE ( предикат ) ] |
  FOREIGN KEY ( имя_столбца [, ... ] ) REFERENCES целевая_таблица [ ( целевой_столбец [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE действие ] [ ON UPDATE действие ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

и вариант_копирования:

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }

параметры_индекса в ограничениях UNIQUE, PRIMARY KEY и EXCLUDE:

[ WITH ( параметр_хранения [= значение] [, ... ] ) ]
[ USING INDEX TABLESPACE табл_пространство ]

элемент_исключения в ограничении EXCLUDE:

{ имя_столбца | ( выражение ) } [ класс_операторов ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]

Описание


Ограничения CHECK объединяются вместе по сути так же, 
как и столбцы: если несколько родительских таблиц и/или определение новой таблицы содержат одноимённые ограничения CHECK, 
этим ограничениям должны соответствовать одинаковые выражения проверки, в противном случае произойдёт ошибка. В случае совпадения выражения, 
эти ограничения с данным выражением объединяются в одно. При этом ограничения со свойством NO INHERIT в родительской таблице исключаются из рассмотрения. 
Заметьте, что безымянное ограничение CHECK в новой таблице никогда не сливается с другими, так как для него всегда выбирается уникальное имя.

Параметры STORAGE для столбца так же копируются из родительских таблиц.

LIKE исходная_таблица [ вариант_копирования ... ]
Предложение LIKE определяет таблицу, из которой в новую таблицу будут автоматически скопированы все имена столбцов, их типы данных и их ограничения на NULL.

В отличие от INHERITS, новая и исходная таблица становятся полностью независимыми после завершения создания. Изменения в исходной таблице не отражаются в новой, 
а данные новой таблицы не включаются в результат чтения исходной.

Выражения значений по умолчанию в определениях копируемых столбцов переносятся в новую таблицу, 
только если дополнительно указано INCLUDING DEFAULTS. Без этого указания выражения по умолчанию не копируются, 
вследствие чего в новой таблице скопированные столбцы получают значения по умолчанию NULL. 
Заметьте, что при копировании выражений по умолчанию, которые вызывают функции, модифицирующие БД, как например nextval, 
может образовываться функциональная связь исходной таблицы с новой.

Ограничения NULL копируются в новую таблицу всегда, а ограничения CHECK копируются только при явном указании INCLUDING CONSTRAINTS. 
Это в равной мере касается ограничений как таблиц, так и столбцов.

Индексы, свойство PRIMARY KEY, а также ограничения UNIQUE и EXCLUDE копируются из исходной таблицы в новую, только если явно указано INCLUDING INDEXES. 
Имена для новых индексов и ограничений выбираются согласно стандартным правилам, независимо от того, как назывались исходные. 
(Это позволяет избежать ошибок с дублированием имён с новыми индексами.)

Параметры STORAGE будут перенесены в определение копируемых столбцов, только если явно указывается INCLUDING STORAGE. 
По умолчанию параметры STORAGE исключаются, вследствие чего скопированные столбцы в новой таблице получают параметры по умолчанию, 
определённые соответствующим типом. Подробнее параметры STORAGE описаны в Разделе 63.2.

Комментарии для скопированных столбцов, ограничений и индексов будут копироваться, только если явно указано INCLUDING COMMENTS. 
По умолчанию комментарии исключаются, вследствие чего скопированные столбцы и ограничения в новой таблице оказываются без комментариев.

Предложение INCLUDING ALL является сокращённой формой развёрнутого предложения 
INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS.

Заметьте, что в отличие от INHERITS, столбцы и ограничения, копируемые командой LIKE, 
не объединяются с одноимёнными столбцами и ограничениями. Если дублирующееся имя указывается явно или возникает в другом предложении LIKE, происходит ошибка.

Предложение LIKE может также применяться для копирования определений столбцов из представлений, 
сторонних таблиц и составных типов. Неприменимые параметры (например, INCLUDING INDEXES для представления) при этом игнорируются.

CONSTRAINT имя_ограничения
Необязательное имя столбца или ограничения таблицы. При нарушении ограничения его имя будет выводиться в сообщении об ошибках,
так что имена ограничений вида столбец должен быть положительным могут сообщить полезную информацию об ограничении клиентскому приложению. 
(Имена ограничений, включающие пробелы, необходимо заключать в двойные кавычки.) Если имя ограничения не указано, система генерирует имя автоматически.

NOT NULL
Данный столбец не принимает значения NULL.

NULL
Данный столбец может содержать значения NULL (по умолчанию).

Это предложение предназначено только для совместимости с нестандартными базами данных SQL. Использовать его в новых приложениях не рекомендуется.

CHECK ( выражение ) [ NO INHERIT ]
В ограничении CHECK задаётся выражение, возвращающее булевский результат, по которому определяется, 
будет ли успешна операция добавления или изменения для конкретных строк. Операция выполняется успешно, 
если результат выражения равен TRUE или UNKNOWN. Если же для какой-нибудь строки, задействованной в операции добавления или изменения, 
будет получен результат FALSE, возникает ошибка, и эта операция не меняет ничего в базе данных. Ограничение-проверка, заданное как ограничение столбца, 
должно ссылаться только на значение самого столбца, тогда как ограничение на уровне таблицы может ссылаться и на несколько столбцов.

В настоящее время выражения CHECK не могут содержать подзапросы или ссылаться на переменные, кроме как на столбцы текущей строки. 
Также допустима ссылка на системный столбец tableoid, но не на другие системные столбцы.

Ограничение с пометкой NO INHERIT не будет наследоваться дочерними таблицами.

Когда для таблицы задано несколько ограничений CHECK, 
они будут проверяться для каждой строки в алфавитном порядке имён после проверки ограничений NOT NULL. 
(До версии 9.5 в PostgreSQL не было установлено никакого определённого порядка обработки ограничений CHECK.)

DEFAULT выражение_по_умолчанию
Предложение DEFAULT задаёт значение по умолчанию для столбца, в определении которого оно присутствует. 
Значение задаётся выражением без переменных (подзапросы и перекрёстные ссылки на другие столбцы текущей таблицы в нём не допускаются). 
Тип данных выражения, задающего значение по умолчанию, должен соответствовать типу данных столбца.

Это выражение будет использоваться во всех операциях добавления данных, в которых не задаётся значение данного столбца. 
Если значение по умолчанию не определено, таким значением будет NULL.

TABLESPACE табл_пространство
Здесь табл_пространство — имя табличного пространства, в котором будет создаваться новая таблица. 
Если оно не указано, выбирается default_tablespace или temp_tablespaces, если таблица временная.

USING INDEX TABLESPACE табл_пространство
Это предложение позволяет выбрать табличное пространство, в котором будут создаваться индексы, связанные с ограничениями UNIQUE, 
PRIMARY KEY или EXCLUDE. Если оно не указано, выбирается default_tablespace или temp_tablespaces, если таблица временная.

Параметры хранения
Предложение WITH позволяет установить параметры хранения для таблиц и индексов, связанных с ограничениями 
UNIQUE, PRIMARY KEY и EXCLUDE. Параметры хранения для индексов документированы в CREATE INDEX. 
Поддерживаемые в настоящее время параметры хранения для таблиц перечислены ниже. Как показано, 
для каждого параметра существует дополнительный параметр с тем же именем и префиксом toast., который управляет поведением вторичной таблицы TOAST, 
если она есть (за дополнительными сведениями о TOAST обратитесь к Разделу 63.2). Если значение некоторого параметра задано для таблицы, 
а значение равнозначного параметра toast. не определено, для таблицы TOAST будет применяться значение параметра основной таблицы.

fillfactor (integer)
Фактор заполнения для таблицы, задаваемый в процентах, от 10 до 100. Значение по умолчанию — 100 (плотное заполнение). 
При меньшем факторе заполнения операции INSERT упаковывают данные в страницы только до заданного процента; 
оставшееся место резервируется для изменения строк на этой странице. В результате UPDATE получает шанс поместить изменённую копию строки в ту же страницу, 
что и исходную, что гораздо эффективнее, чем размещать её на другой странице. Для таблиц, записи в которых никогда не меняются, лучшим выбором будет плотное заполнение, 
но для активно изменяемых таблиц лучше выбрать меньший фактор заполнения. Этот параметр нельзя задать для таблиц TOAST.
```
