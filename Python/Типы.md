Проверить тип данных в переменной
```python
var = 0
type(var)
```
Сравнить тип данных в переменной:
```python
if isinstance(obj, int):
	type(obj)
```

## Последовательности (Sequence Types)

Последовательности — это **упорядоченные коллекции элементов**, доступ к которым осуществляется по индексу. В Python есть несколько встроенных типов последовательностей, отличающихся **изменяемостью, синтаксисом и назначением**.  
### Типы

| **Тип**     | **Синтаксис**        | **Описание**                                                                                  |
| ----------- | -------------------- | --------------------------------------------------------------------------------------------- |
| `str`       | `"текст"`, `'текст'` | Неизменяемый - Строка символов (Unicode). Поддерживает срезы, методы (`upper()`, `split()`).  |
| `list`      | `[1, 2, 3]`          | Изменяемый - Упорядоченная коллекция элементов любого типа. Поддерживает добавление/удаление. |
| `tuple`     | `(1, 2, 3)`          | Неизменяемый - Аналог списка, но не может изменяться после создания. Быстрее `list`.          |
| `range`     | `range(5)`           | Неизменяемый - Последовательность чисел (`0, 1, 2, 3, 4`). Экономит память.                   |
| `bytes`     | `b'abc'`             | Неизменяемый - Последовательность байтов (0-255). Используется для бинарных данных.           |
| `bytearray` | `bytearray(b'abc')`  | Изменяемый - Аналог `bytes`, но можно изменять.                                               |
### Операции 

| **Операция**                  | **Пример**           | **Результат**  |
| ----------------------------- | -------------------- | -------------- |
| Индексация (`[i]`)            | `"abc"[1]`           | `'b'`          |
| Срезы (`[start:stop:step]`)   | `"hello"[1:4]`       | `'ell'`        |
| Длина (`len()`)               | `len([1, 2, 3])`     | `3`            |
| Конкатенация (`+`)            | `[1, 2] + [3, 4]`    | `[1, 2, 3, 4]` |
| Повторение (`*`)              | `"a" * 3`            | `'aaa'`        |
| Проверка вхождения (`in`)     | `2 in [1, 2, 3]`     | `True`         |
| Минимум/максимум (`min/max`)  | `min("abc")`         | `'a'`          |
| Индекс элемента (`index()`)   | `"abc".index('b')`   | `1`            |
| Подсчёт элементов (`count()`) | `[1, 2, 2].count(2)` | `2`            |
### Особенности

#### `str` - строка
- **Неизменяемая**, попытка модификации создаёт новую строку.  
- Полезные методы:  
```python
  text = "Hello, World!"
  print(text.upper())       # "HELLO, WORLD!"
  print(text.split(","))    # ['Hello', ' World!']
  print(text.replace("H", "J"))  # "Jello, World!"
  ```

#### `list` - список
- **Изменяемый**, можно добавлять (`append()`), удалять (`pop()`, `remove()`), изменять элементы.  
- Может содержать **разные типы данных**:  
```python
  mixed = [1, "text", True, [1, 2]]
  mixed[0] = 100  # Замена элемента
  ```
- Полезные методы:
```python
# Добавляет элемент в конец списка
list.append()

# Добавляет элемент по указанному индексу списка 
list.insert(index, name)

# Добавляет в список повторяющиеся элементы 
list.extend("ABC") or list.extend([3, 4]) or list.extend((3, 4))

# Объединение списков
listConcat = [] + []
```
#### `tuple` - кортеж
- **Неизменяемый**, поэтому **быстрее списка**.  
  ```python
  point = 10, 20
- point = (10, 20)
  ```

#### `range` - диапазон
- **Ленивая последовательность** (генерирует числа).  
- Используется в циклах:  
  ```python
  for i in range(5):  # 0, 1, 2, 3, 4
      print(i)
  ```
- Можно задать шаг: `range(0, 10, 2)` → `0, 2, 4, 6, 8`.

#### `bytes` и `bytearray` - байтовые строки
- `bytes` — **неизменяемый**, `bytearray` — **изменяемый**.  
- Используются для работы с **бинарными данными**.  
- Пример: 
  ```python
  data = b'ABC'          # bytes
  mutable_data = bytearray(data)
  mutable_data[0] = 88   # bytearray(b'XBC')
  ```

## Числовые типы (Numeric Types)

Числовые типы в Python используются для хранения числовых данных. Они поддерживают различные виды чисел: целые, вещественные, комплексные и специальные типы для точных вычислений. 
### Типы

| **Тип**   | **Описание**                      | **Пример**              | **Особенности**                             |
| --------- | --------------------------------- | ----------------------- | ------------------------------------------- |
| `int`     | Целое число произвольной точности | `42`, `-10`, `10_000`   | Нет ограничений на размер (кроме памяти).   |
| `float`   | Число с плавающей точкой (64-bit) | `3.14`, `-0.001`, `2e3` | Может вызывать ошибки округления.           |
| `complex` | Комплексное число (`a + bj`)      | `2 + 3j`, `1j`, `-4+0j` | Мнимая часть обозначается через `j`.        |
| `bool`    | Логический тип (`True`/`False`)   | `True`, `False`         | Подкласс `int` (`True == 1`, `False == 0`). |
### Типы из модулей

| **Тип**                 | **Описание**                           | **Пример**                        |
| ----------------------- | -------------------------------------- | --------------------------------- |
| `decimal.Decimal`       | Число с фиксированной точностью        | `Decimal('0.1')`                  |
| `fractions.Fraction`    | Дробь (числитель / знаменатель)        | `Fraction(1, 3)`                  |
| `numpy.int32`/`float64` | Числа с фиксированным размером (NumPy) | `np.int32(5)`, `np.float64(3.14)` |
### Операции

#### Арифметические операции

| **Операция**                               | **Пример** | **Результат** |
| ------------------------------------------ | ---------- | ------------- |
| Сложение (`+`)                             | `3 + 2`    | `5`           |
| Вычитание (`-`) (бинарный минус)           | `5 - 3`    | `2`           |
| Умножение (`*`)                            | `2 * 3`    | `6`           |
| Деление (`/`)                              | `10 / 3`   | `3.333...`    |
| Целочисленное деление (`//`)               | `10 // 3`  | `3`           |
| Остаток от деления (`%`)                   | `10 % 3`   | `1`           |
| Возведение в степень (`**`)                | `2 ** 3`   | `8`           |
| Унарный минус (отрицательное число) `-(n)` | `-(1)`     | `-1`          |
> `**` является правоассоциативным (вычисляется справа налево)
> `//` всегда округляет только в **меньшую сторону**

#### Сравнение чисел

| **Операция**    | **Пример** | **Результат** |
| --------------- | ---------- | ------------- |
| Равно (`==`)    | `5 == 5.0` | `True`        |
| Не равно (`!=`) | `3 != 2`   | `True`        |
| Больше (`>`)    | `10 > 5`   | `True`        |
| Меньше (`<`)    | `3 < 2`    | `False`       |
#### Математические функции
```python
import math

print(math.sqrt(16))    # 4.0 (квадратный корень)
print(math.pow(2, 3))   # 8.0 (степень)
print(abs(-5))          # 5 (модуль)
print(round(3.14159, 2))  # 3.14 (округление)
```
### Особенности

#### `int` - Целые числа
- Поддерживают **очень большие значения** (ограничено только памятью).  
- Можно записывать с подчёркиваниями для удобства:  
  ```python
  big_num = 1_000_000  # Аналогично 1000000
  ```
#### `float` - Вещественные числа
- Используют **двоичное представление**, поэтому возможны ошибки округления:  
  ```python
  0.1 + 0.2 == 0.3  # False (на самом деле 0.30000000000000004)
  ```
- Для точных расчётов `decimal.Decimal`:  
  ```python
  from decimal import Decimal
  Decimal('0.1') + Decimal('0.2') == Decimal('0.3')  # True
  ```
#### `complex` - Комплексные числа
- Состоят из **действительной** и **мнимой** части:  
  ```python
  z = 2 + 3j
  print(z.real)  # 2.0
  print(z.imag)  # 3.0
  ```
#### `bool` - Логический тип
- Является подклассом `int`:  
  ```python
  print(True + 1)  # 2
  print(False * 10) # 0
  ```
### Алгоритм получения цифр `n`-значного числа:

>Последняя цифра числа определяется всегда как **остаток от деления** числа на `10 % 10`. Чтобы отщепить последнюю цифру от числа, необходимо разделить его **нацело** на `10 // 10`.

- Вторая цифра: `(num % 10n-1) // 10n-2`;
- Первая цифра: `(num % 10n) // 10n-1`.

>n = 12345
>
>print(n % 10 // 1)\
>print(n % 100 // 10)\
>print(n % 1000 // 100)\
>print(n % 10000 // 1000)\
>print(n % 100000 // 10000)
>
>print(n // 1)\
>print(n // 10)\
>print(n // 100)\
>print(n // 1000)\
>print(n // 10000)


>print(n % 1)\
>print(n % 10)\
>print(n % 100)\
>print(n % 1000)\
>print(n % 10000)\
>print(n % 100000)

>5\
>4\
>3\
>2\
>1


>12345\
>1234\
>123\
>12\
>1

>0\
>5\
>45\
>345\
>2345\
>12345

## Множества (Set Types)

Множества — это **неупорядоченные коллекции уникальных элементов**. Они используются для быстрой проверки вхождения, удаления дубликатов и выполнения математических операций над множествами.  
- Элементы множества должны быть **хешируемыми** (нельзя использовать `list` или `dict` внутри `set`).  
### Типы

| **Тип**     | **Синтаксис**       | **Описание**                                                                                                         |
| ----------- | ------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `set`       | `{1, 2, 3}`         | Изменяемое - Хранит только уникальные элементы. Поддерживает добавление/удаление.<br>Когда нужно изменять множество. |
| `frozenset` | `frozenset({1, 2})` | Неизменяемое - Аналог `set`, но нельзя изменить. Когда множество должно быть неизменяемым, ключ в `dict`.            |
### Операции

| **Операция**              | **Пример**       | **Результат**                   |
| ------------------------- | ---------------- | ------------------------------- |
| Создание                  | `s = {1, 2, 3}`  | `{1, 2, 3}`                     |
| Пустое множество          | `s = set()`      | `set()` (не `{}`, это словарь!) |
| Добавление элемента       | `s.add(4)`       | `{1, 2, 3, 4}`                  |
| Удаление элемента         | `s.remove(3)`    | `{1, 2, 4}` (KeyError если нет) |
| Проверка вхождения (`in`) | `2 in {1, 2, 3}` | `True`                          |
| Длина (`len()`)           | `len({1, 2, 3})` | `3`                             |
#### Математические операции

| **Операция**                | **Синтаксис** | **Результат**                                     |
| --------------------------- | ------------- | ------------------------------------------------- |
| Объединение (`\|`)          | `a\|b`        | Все элементы из `a` и `b`                         |
| Пересечение (`&`)           | `a & b`       | Элементы, общие для `a` и `b`                     |
| Разность (`-`)              | `a - b`       | Элементы `a`, которых нет в `b`                   |
| Симметричная разность (`^`) | `a ^ b`       | Элементы, которые есть только в одном из множеств |
#### Сравнение множеств

| **Операция**               | **Пример** | **Описание**                |
| -------------------------- | ---------- | --------------------------- |
| Подмножество (`<=`)        | `a <= b`   | Все элементы `a` есть в `b` |
| Надмножество (`>=`)        | `a >= b`   | Все элементы `b` есть в `a` |
| Строгое подмножество (`<`) | `a < b`    | `a <= b` и `a != b`         |
### Применение

```python
# Удаление дубликатов из списка
lst = [1, 2, 2, 3, 3, 3]
unique = list(set(lst))  # [1, 2, 3]

# Проверка вхождения элемента
valid_users = {"alice", "bob", "charlie"}
user = "bob"
print(user in valid_users)  # True

# Операции над множествами
A = {1, 2, 3}
B = {3, 4, 5}

print(A | B)  # {1, 2, 3, 4, 5} (объединение)
print(A & B)  # {3} (пересечение)
print(A - B)  # {1, 2} (разность)
print(A ^ B)  # {1, 2, 4, 5} (симметричная разность)

# `frozenset` (неизменяемое множество)
fs = frozenset([1, 2, 3])
d = {fs: "value"}  # Можно использовать как ключ в словаре
```

## `dict` - словарь

Изменяемая коллекция пар **ключ-значение**, где ключи должны быть уникальными и хешируемыми. Изменяемый (можно добавлять, удалять, изменять элементы). Сохраняет порядок вставки. Требует больше памяти, чем у списков/кортежей, но очень эффективный доступ.

```python
# Пустой словарь
d1 = {}
d2 = dict()

# Словарь с элементами
info = {
    "name": "test",
    "age": 25,
    "skills": ["test1", "test2"]
}

# Создание через dict()
numbers = dict(one=1, two=2)  # {'one': 1, 'two': 2}
```
### Операции

```python
# Доступ к элементам
user = {"name": "John", "age": 25}

print(user["name"])  # "John" (KeyError, если ключа нет)
print(user.get("age"))  # 25 (возвращает None, если ключа нет)
print(user.get("address", "N/A"))  # "N/A" (значение по умолчанию)

# Добавление и изменение
user["email"] = "john@example.com"  # Добавляет новую пару
user["age"] = 26  # Изменяет существующее значение

# Удаление элементов
del user["email"]  # Удаляет ключ "email" (KeyError, если нет)
age = user.pop("age")  # Удаляет и возвращает значение (25)
user.clear()  # Очищает весь словарь

# Проверка наличия ключа
if "name" in user:
    print("Ключ существует")

# Итерация по словарю
for key in user:           # Перебор ключей
    print(key)

for value in user.values():  # Перебор значений
    print(value)

for key, value in user.items():  # Перебор пар ключ-значение
    print(f"{key}: {value}")
```
### Методы

| **Метод**       | **Описание**                                                                  | **Пример**                               |
| --------------- | ----------------------------------------------------------------------------- | ---------------------------------------- |
| `.keys()`       | Возвращает список ключей                                                      | `user.keys() → ["name", "age"]`          |
| `.values()`     | Возвращает список значений                                                    | `user.values() → ["John", 25]`           |
| `.items()`      | Возвращает пары ключ-значение                                                 | `user.items() → [("name", "John"), ...]` |
| `.update()`     | Объединяет два словаря                                                        | `user.update({"city": "NY"})`            |
| `.setdefault()` | Возвращает значение, если ключ есть, иначе добавляет ключ с default-значением | `user.setdefault("age", 30)`             |
| `.popitem()`    | Удаляет и возвращает последнюю пару (LIFO)                                    | `user.popitem() → ("age", 25)`           |
| `.fromkeys()`   | Создаёт словарь с ключами из последовательности и общим значением             | `dict.fromkeys(["a", "b"], 0)`           |

```python
# Сортировка словарей
# Сортировка по ключам
sorted_dict = dict(sorted(user.items()))

# Сортировка по значениям
sorted_by_age = dict(sorted(user.items(), key=lambda x: x[1]))

# Объединение оператором |
dict1 = {"a": 1}
dict2 = {"b": 2}
merged = dict1 | dict2  # {"a": 1, "b": 2}

# Словари с вычисляемыми значениями (defaultdict)
from collections import defaultdict

dd = defaultdict(int)  # При обращении к несуществующему ключу возвращает 0
dd["count"] += 1  # Автоматически инициализируется 0
```