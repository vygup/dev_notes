## Основная информация

**Python** - язык с динамической типизацией, он динамически адаптирует переменные в нужный тип данных.

**Объект** (он же **значение**): Списки, словари, строки, числа, кортежи, функции и модули.

**Переменные** - это **указатели** или **ссылки** на объекты (сами по себе переменные ничего не хранят).

**Оператор присваивания** `=` указывает переменную на объект.
>_Оператор присваивания ничего не копирует_: он просто указывает переменную на объект. Таким образом, присвоение одной переменной другой просто указывает их на один и тот же объект.
>Если переменные указывают на _объекты, представляющие одни и те же данные_, то они не будут являться одним и тем же объектом.

**Название переменной** в Python должно начинаться с латинской буквы или со знака подчеркивания и может содержать латинские буквы, цифровые символы и знак подчеркивания. И кроме того, название переменной не должно совпадать с названием ключевых слов языка Python.

Применяется два типа наименования переменных: `camel case` и `underscore notation` (`snake case`)

`Mixed case` подразумевает, что каждое новое подслово в наименовании переменной начинается с большой буквы. Например:
```python
userName = 'Tom'
```

`Camel case` подразумевает, что все слова начинаются с большой буквы. Например:
```python
UserName = 'Tom'
```

`Underscore notation` (`snake case`) подразумевает, что подслова в наименовании переменной разделяются знаком подчеркивания. Например:
```python
user_name = 'Tom'
```

`flat case` подразумевает, что используется только нижний регистр. Например:
```python
username = 'Tom'
```

И также надо учитывать регистрозависимость:
> Переменные `name` и `Name` будут представлять разные объекты.

## Немного глубины

```python
numbers = [2, 1, 3, 4, 7]
numbers2 = numbers
name = "Trey"
```
Состояние переменных и объектов будет выглядеть так:

![](./attach/Pasted%20image%2020240525230215.png)

### Два типа `изменения` в Python

В Python есть два различных типа `изменения`:

1. **Присваивание** изменяет переменную (указывает на другой объект, оставляя исходный объект неизменным).
2. **Мутация** изменяет объект (меняет исходный объект, на который могут ссылаться другие переменные).
>Числа и строки являются иммутабельными, то есть их нельзя изменить.
>Для иммутабельных объектов дополненные присваивания (`+=`, `*=`, `%=` и т.д.) выполняют операцию (которая возвращает новый объект), а затем выполняют присваивание (этому новому объекту).

### Структуры данных

Как и переменные, структуры данных не содержат объектов, они содержат указатели на объекты.
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

row = matrix[1]
```
Состояние переменных и объектов будет выглядеть так:

![](./attach/Pasted%20image%2020240525230111.png)

Поэтому, если мы изменим список, на который указывает `row`, мы увидим изменение в обоих местах

### Аргументы функций действуют как операторы присваивания

Вызовы функций также выполняют присваивание.

Если вы мутируете объект, который был передан в вашу функцию, вы также мутировали исходный объект:

```python
def smallest_n(items, n):
	items.sort()
	return items[:n]
		
numbers = [29, 7, 1, 4, 11, 18, 2]

smallest_n(numbers, 4)
>>>[1, 2, 4, 7]

numbers
>>>[1, 2, 4, 7, 11, 18, 29]
```
Но если вы переназначите переменную другому объекту, исходный объект не изменится:

```python
def smallest_n(items, n):
	items = sorted(items)
    return items[:n]

numbers = [29, 7, 1, 4, 11, 18, 2]

smallest_n(numbers, 4)
>>>[1, 2, 4, 7]

numbers
>>>[29, 7, 1, 4, 11, 18, 2]
```

Здесь мы переназначаем переменную `items`. Данное переназначение изменяет объект, _на который_ указывает переменная `items`, но при этом не изменяет исходный объект.

В первом случае мы изменили объект, а во втором - изменили переменную.

**Не мутируйте объекты**, переданные в вашу функцию, если этого не ожидает вызывающая функция.

Если требуется сделать копию, то лучше это сделать не через `b = a`, а через `b = объект/ы из переменной a`

Узнать это поможет оператор `is` - проверяет тождество и оператор `==` - равенство.
Если переменная ссылается не на те же объекты, а на одинаковые данные в объектах, то `is` выведет `False`, а `==` выведет `True`.

Поскольку целые числа (и все числа) в Python иммутабельны, нам не важно, что каждый список содержит одни и те же объекты, поскольку мы все равно не можем их мутировать.

С мутабельными объектами данное различие имеет значение. В этом случае получается два списка списков, каждый из которых содержит указатели на одни и те же два списка:
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_matrix = list(matrix)
```

Эти два списка не одинаковы, но каждый элемент в них один и тот же:
```python
matrix is new_matrix
>>> False

matrix[0] is new_matrix[0]
>>> True
```

Состояние переменных и объектов будет выглядеть так:

![](./attach/Pasted%20image%2020240526001313.png)

Пример иммутабельности и мутабельности:
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
b = matrix
new_matrix = list(matrix)

matrix.append(10)
print(matrix, b, new_matrix, sep = '\n')

>>> [[1, 2, 3], [4, 5, 6], [7, 8, 9], 10] 
>>> [[1, 2, 3], [4, 5, 6], [7, 8, 9], 10]
>>> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

matrix[0].append(10)
print(matrix, b, new_matrix, sep = '\n')

>>> [[1, 2, 3, 10], [4, 5, 6], [7, 8, 9], 10] 
>>> [[1, 2, 3, 10], [4, 5, 6], [7, 8, 9], 10] 
>>> [[1, 2, 3, 10], [4, 5, 6], [7, 8, 9]]
```

При копировании объектов в котором находятся другие объекты, то копируются указатели на них, а не сами объекты.

### Решение проблемы с мутацией
Для рекурсивного копирования структур данных существует  `deepcopy`:
```python
from copy import deepcopy
from datetime import datetime

tweet_data = [{"date": "Feb 04 2014", "text": "test1"}, {"date": "Apr 16 2014", "text": "test2"}]

processed_data = deepcopy(tweet_data)
for tweet in processed_data:
	tweet["date"] = datetime.strptime(tweet["date"], "%b %d %Y")
```

Другой, _более лаконичный_ способ, это создать еще один список новых словарей вместо глубокого копирования старого списка словарей методом `deepcopy`.

```python
processed_data = [
	{**tweet, "date": datetime.strptime(tweet["date"], "%b %d %Y")}    
	for tweet in tweet_data]
```

> Но это все не пригодится если нет нужды мутировать объекты.

### Итог

Структуры данных, списки и словари содержат указатели на объекты, а не сами объекты. Аналогично работают и атрибуты: атрибуты указывают на объекты (точно так же, как любая переменная указывает на объект).
>Объекты не могут содержать объекты в Python (они могут только _указывать_ на них).

Мутации изменяют объекты (а не переменные), несколько переменных _могут_ указывать на один и тот же объект. Если две переменные указывают на один и тот же объект, изменения этого объекта будут видны при обращении к любой из этих переменных (поскольку они обе указывают на _один и тот же_ объект).



## Работа с переменными
Также можно присвоить к нескольким переменным значение за 1 инструкцию 
```python
v1, v2 = 1, 2
```

Встроенная функция для хранения всех переменных внутри программы:
```python
dir()
```

Локальные переменные:
```python
locals()
# Чтобы получить значение переменной 
locals()['name_per']
# Вывод названия переменной
set(locals())
```


Глобальные переменные:
```python
globals()
```